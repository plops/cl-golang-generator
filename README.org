* Introduction

Common Lisp program that transforms s-expressions into Go language. It
is currently still work in progress.


This is the sixth in a series of code generators.

- https://github.com/plops/cl-cpp-generator I tried this generator
  with C/C++/ISPC/OpenCL/Cuda. It was my first attempt. The largest
  project with this is a firmware for a microcontroller. The difficult
  part is to get placement of semicolons right. I'm not terribly happy
  with the current solution. People don't like that every function
  call has to be explicitly stated as such. Initially I thought it
  would help me to add function parameter completion in emacs. But I
  never figured out how to do that and in later code generators I
  simplified the lisp syntax.

- https://github.com/plops/cl-ada-generator (abandoned) I always
  wanted to have a VHDL code generator and thought that ADA would be a
  good target to support a similar language. Unfortunately ADA and
  VHDL have a lot of syntactic constructs which I find difficult to
  express in Lisp semantics that I can remember. So I stopped working
  in this direction.

- https://github.com/plops/cl-py-generator At a new job I generated
  LOTS of python code (75k lines) with this generator. The difficult
  part was to get indents right. It works really well. I should
  backport some features from cl-golang-generator: Variable type
  declaration, when, unless, unitary - and unitary /, logior, logand,
  incf, decf.

- https://github.com/plops/cl-js-generator I played around with webrtc
  and webgl in the browser.  I used parenscript before and I really
  like the way it upholds lisp semantics (every expression returns a
  value). However, the generated javascript can be difficult to read
  (and compare to s-expressions). For this project my goal was to have
  a very minimal mapping from s-expressions to javascript. Turns out
  converting lisp to javascript is very straightforward.

- https://github.com/plops/cl-wolfram-generator (abandoned) At some
  point I was able to download a wolfram language license. I think
  this language is very close to Lisp. I tried some code generation
  but the free license would only work on one computer which is not
  how I work.


cl-golang-generator is based on cl-py-generator. Go doesn't really
need indenting (go fmt can fix this) and also doesn't have lots of
semicolons (like C). That makes the s-expression to golang conversion
quite simple. The hardest part for this code generator is to support
type declaration. I did the simplest possible thing and only search
for declarations in the first forms of the body of let and defun. I
really like that solution. It can even notice (most of the time) if a
variable has a typo in the declaration.

* Syntax

| lisp                | comment                        | example                     | expanded          |   |   |   |   |   |
|---------------------+--------------------------------+-----------------------------+-------------------+---+---+---+---+---|
| ntuple              | comma separated list           | (:= (ntuple val err) (bla)) | val, err := bla() |   |   |   |   |   |
| paren               | comma separated list in parens | (paren 1 2 3)               | (1,2,3)           |   |   |   |   |   |
| braces              | comma separated list in braces | (braces 1 2 3)              | {1,2,3}           |   |   |   |   |   |
| curly               | for instantiation              | (curly []int 1 2 3)         | []int{1,2,3}      |   |   |   |   |   |
| cast                | like a funcall without parens  |                             |                   |   |   |   |   |   |
| dict                |                                |                             |                   |   |   |   |   |   |
| do0                 | combine instructions           |                             |                   |   |   |   |   |   |
| let                 | var declaration                |                             |                   |   |   |   |   |   |
| assign              | ":=" declaration               |                             |                   |   |   |   |   |   |
| ":="                | ":=" declaration use in for    |                             |                   |   |   |   |   |   |
| defun               |                                |                             |                   |   |   |   |   |   |
| defun-declaration   | for type declaration           |                             |                   |   |   |   |   |   |
| lambda              | unnamed function               |                             |                   |   |   |   |   |   |
| defmethod           |                                |                             |                   |   |   |   |   |   |
| defmethod-interface | for interface declaration      |                             |                   |   |   |   |   |   |
| defstruct0          | struct declaration             |                             |                   |   |   |   |   |   |
| deftype             |                                |                             |                   |   |   |   |   |   |
| definterface        |                                |                             |                   |   |   |   |   |   |
| setf                | several =                      |                             |                   |   |   |   |   |   |
| const               | several const declarations     |                             |                   |   |   |   |   |   |
| if                  |                                |                             |                   |   |   |   |   |   |
| when                | easier than if for multi form  |                             |                   |   |   |   |   |   |
| unless              |                                |                             |                   |   |   |   |   |   |
| case                | switch statement               |                             |                   |   |   |   |   |   |
| ecase               | like case but without default  |                             |                   |   |   |   |   |   |
| for                 |                                |                             |                   |   |   |   |   |   |
| foreach             |                                |                             |                   |   |   |   |   |   |
| while               |                                |                             |                   |   |   |   |   |   |
| dotimes             |                                |                             |                   |   |   |   |   |   |
| not                 |                                |                             |                   |   |   |   |   |   |
| "+,-,*,/"           |                                |                             |                   |   |   |   |   |   |
| logior, logand      |                                |                             |                   |   |   |   |   |   |
| or, and             |                                |                             |                   |   |   |   |   |   |
| "/=,^=,<=,!=,=='    |                                |                             |                   |   |   |   |   |   |
| <-                  |                                |                             |                   |   |   |   |   |   |
| "<,<<,>>"           |                                |                             |                   |   |   |   |   |   |
| incf, decf          |                                |                             |                   |   |   |   |   |   |
| string              |                                |                             |                   |   |   |   |   |   |
| char                |                                |                             |                   |   |   |   |   |   |
| aref                | array access                   |                             |                   |   |   |   |   |   |
| slice               |                                |                             |                   |   |   |   |   |   |
| dot                 | combine with dots              |                             |                   |   |   |   |   |   |
|                     |                                |                             |                   |   |   |   |   |   |



** special instructions

- like a function call but without parens: go, range, chan, defer, return

* Known problems:

- Currently the example code generation relies on the repo being
  /home/martin/stage/cl-golang-generator. This can should be changed
  in each gen.lisp file by modifying the defparameter *path*. Of
  course this is unacceptable. I haven't figured out how to get the
  repo path using asdf or defsystem.

- I don't quite understand how go directories should be layed out. I
  guess I should read golang-standards/project-layout at some point.



* References

- https://github.com/golang-standards/project-layout go directory layout
- https://common-lisp.net/project/parse-declarations/manual/parse-declarations.html perhaps i should use this to parse type declarations in defun and let
- https://github.com/google/grumpy python to go (i didn't look at it but it seems somewhat related)

- go repl
  - go get -u github.com/motemen/gore/cmd/gore
  - go get -u github.com/mdempsky/gocode  
  - go get -u github.com/k0kubun/pp  

- http://go-database-sql.org/modifying.html database
